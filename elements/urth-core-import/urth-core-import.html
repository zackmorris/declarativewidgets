<!--
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
-->
<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='../iron-ajax/iron-ajax.html'>
<link rel="import" href="../urth-core-behaviors/jupyter-widget-behavior.html">
<link rel='import' href='../urth-core-behaviors/jupyter-notebook-env.html'>

<!--
 Adds functionality to `<link>` to provide a mechanism to
 install web components registered as [bower](http://bower.io/) packages. This
 element works with a server side REST endpoint to install the specified package
 and then upon successfull install, injects the appropriate HTML import into the page.

 The `href` attribute should be specified as a relative path as the appropriate
 base URL for the environment will be prefixed automatically. In the notebook
 all `href` values should be of the form `urth_components/<package_name>/<file>`.

 Example: _Install and import the paper-slider element_

 ```html
 <link rel='import' href='urth_components/paper-slider/paper-slider.html'
        is='urth-core-import' package='PolymerElements/paper-slider'>
 ```

 @group Urth Core
 @element urth-core-import
 -->
<dom-module id='urth-core-import'>
    <template>
        <iron-ajax id='ajaxPost' url='{{_importEndpointURL}}'
            body='{{requestBody}}'
            content-type='application/json'
            handle-as='json'
            method='POST'></iron-ajax>
    </template>
</dom-module>

<script>
    'use strict';
    var loadedPackages = {},
        logTag = 'urth-core-import: ';

    Polymer({
        is: 'urth-core-import',
        extends: 'link',
        /**
         * fired if the specified package or href fails to load.
         * @event `importerror`
         */

        properties: {
            /**
             * The project dependency to load. Any endpoints that are
             * valid for the [`bower install`](http://bower.io/docs/api/#install)
             * command may be specified.
             */
            package: {
                type: String,
                observer: '_packageChanged',
                reflectToAttribute: true
            },
            /**
             * If `true`, console output will be written to indicate the progress of
             * importing the specified `package`.
             *
             * @default false
             */
            debug: {
                type: Boolean,
                value: false
            },

            /**
             * This is the URL to the import endpoint on the notebook
             */
            _importEndpointURL: {
                computed: "_getImportEndpointURL(_baseURL)"
            },

            importready: {
                type: Boolean,
                value: false,
                readOnly: true
            }
        },

        behaviors: [
            Urth.JupyterWidgetBehavior,
            Urth.JupyterNotebookEnv
        ],

        listeners: {
            'load': '_onLinkLoad'
        },

        attributeChanged: function(name, type) {
            if (name === 'href') {
                this._onHrefAttrChange(this.getAttribute('href'));
            }
        },

        created: function(){
            console.debug(logTag + 'created', arguments);
            this.createModel('urth.widgets.widget_import.Import');
        },

        ready: function() {
            this._onHrefAttrChange(this.getAttribute('href'));
        },

        /*
         * onModelReady is invoked when have created the model portion of the widget
         */
        onModelReady: function(){
            console.debug(logTag + 'onModelReady');

            var syncData = {
                url: window.location.origin + this._importEndpointURL
            }
            console.debug(logTag + 'sending initial sync', syncData);
            this.sync(syncData);
        },

        /*
         * onModelImportreadyChange is invoked by JupyterWidgetBehavior when the `importready` property in
         * the Backbone model changes.
         */
        onModelImportreadyChange: function(newVal){
            console.debug( logTag + 'onModelImportreadyChange', newVal );

            this._setImportready(true);

            if ( this.__pendingImport ){
                this.__pendingImport();
            } else {
                this._downloadPackage();
            }

        },

        /*
         * onModelInstalledChange is invoked by JupyterWidgetBehavior when the `installed` property in
         * the Backbone model changes.
         */
        onModelInstalledChange: function(newVal){
            console.debug( logTag + 'onModelInstalledChange', newVal );

            var url = new URL(this.href);
            url.search += '&urthdummy=urth';

            this.importHref(url.href, function() {
                // Save the fact that the link href was loaded successfully.
                loadedPackages[this.href] = true;
                this.fire('load');
                if (this.debug) {
                    console.debug(logTag + 'Successfully imported ' + url.href);
                }
            }.bind(this), function(e) {
                var msg = 'Failed to import ' + url.href;
                console.warn(logTag + msg);
                this.fire('importerror', { msg: msg });
            }.bind(this));
        },

        _downloadPackage: function() {
            if (this.debug) {
                console.debug(logTag + 'Sending server request to install ' + this.package);
            }

            var _doImport = function(){
                this.send({
                    event: 'import',
                    package: this.package
                });
            }.bind(this);

            if ( this.importready ){
                _doImport();
            } else{
                console.debug(logTag + 'Not ready to import package yet!');
                this.__pendingImport = _doImport
            }

            // // Listen to the 'response' event to handle the ajax POST return value.
            // this.$.ajaxPost.addEventListener('response', function(response) {
            //     if (response && response.detail.status === 200) {
            //         if (this.debug) {
            //             console.debug(logTag + 'Successfully installed ' + this.package);
            //         }
            //
            //         // Add a dummy parameter to the url to force the browser
            //         // to reload.
            //         var url = new URL(this.href);
            //         url.search += '&urthdummy=urth';
            //
            //         this.importHref(url.href, function() {
            //             // Save the fact that the link href was loaded successfully.
            //             loadedPackages[this.href] = true;
            //             this.fire('load');
            //             if (this.debug) {
            //                 console.debug(logTag + 'Successfully imported ' + url.href);
            //             }
            //         }.bind(this), function(e) {
            //             var msg = 'Failed to import ' + url.href;
            //             console.warn(logTag + msg);
            //             this.fire('importerror', { msg: msg });
            //         }.bind(this));
            //     } else {
            //         // Assuming an error has occurred.
            //         var msg = 'Failed to send request to server.';
            //         console.warn(logTag + msg);
            //         this.fire('importerror', { msg: msg });
            //     }
            // }.bind(this));
            //
            // // `iron-ajax` sets xhr errors on the `error` event.
            // this.$.ajaxPost.addEventListener('error', function(error) {
            //     var msg = error && error.detail && error.detail.request &&
            //             error.detail.request.statusText ?
            //             error.detail.request.statusText :
            //             error.detail.error;
            //     console.warn(logTag + msg);
            //     this.fire('importerror', { msg: msg });
            // }.bind(this));
            //
            // this.$.ajaxPost.generateRequest();
        },

        _onHrefAttrChange: function(newHref) {
            // When the href changes, need to inject a new link tag
            // to force the resource to be retrieved. Changing the
            // href dynamically works on Chrome but other browsers
            // require a new link tag so this always injects a new
            // link tag to ensure the new href is retrieved.
            if (newHref && this.rel === 'import') {
                var prefixedHref = this._prefixHref(newHref);
                if (prefixedHref !== newHref) {
                    this.setAttribute('href', prefixedHref);

                    this.importHref(this.href, function() {
                        this.fire('load');
                        if (this.debug) {
                            console.debug(logTag + 'Successfully imported ' + this.href);
                        }
                    }.bind(this), function(e) {
                        // If the href doesn't load, try to download
                        // the package if it is specified.
                        if (this.package && !loadedPackages[this.href]) {
                            this._ownloadPackage();
                        } else {
                            var msg = 'Failed to import ' + this.href;
                            console.warn(logTag + msg);
                            this.fire('importerror', { msg: msg });
                        }
                    }.bind(this));
                }
            }
        },

        _onLinkLoad: function() {
            // Save the fact that the link href was loaded successfully.
            loadedPackages[this.href] = true;
        },

        _packageChanged: function(newVal, oldVal) {
            this.requestBody = '{"package": ' + '"' + newVal + '"}';
        },

        // Imports need to have their href prefixed with the configured
        // import base URL in order to prevent duplication of resources between
        // the notebook initialization and cell imports.
        _prefixHref: function(newHref) {
            if (newHref && this._importBaseURL && newHref.indexOf(this._importBaseURL) !== 0) {
                var prefixed = this._importBaseURL + newHref;
                newHref = this._prefixedHref = prefixed.replace(/((?!:).|^)\/\//g, '$1/');
            }

            return newHref;
        },

        _getImportEndpointURL: function(baseURL) {
            return baseURL + 'urth_import';
        }
    });
</script>
